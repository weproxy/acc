//
// weproxy@foxmail.com 2022/10/03
//

#pragma once

#include "gx/errors/errors.h"
#include "gx/io/io.h"

namespace gx {
namespace binary {

// MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.
const int MaxVarintLen16 = 3;
const int MaxVarintLen32 = 5;
const int MaxVarintLen64 = 10;

// AppendUvarint appends the varint-encoded form of x,
// as generated by PutUvarint, to buf and returns the extended buffer.
slice<> AppendUvarint(slice<> buf, uint64 x) {
    while (x >= 0x80) {
        buf = append(buf, byte(x) | 0x80);
        x >>= 7;
    }
    return append(buf, byte(x));
}

// PutUvarint encodes a uint64 into buf and returns the number of bytes written.
// If the buffer is too small, PutUvarint will panic.
int PutUvarint(slice<> buf, uint64 x) {
    int i = 0;
    while (x >= 0x80) {
        buf[i] = byte(x) | 0x80;
        x >>= 7;
        i++;
    }
    buf[i] = byte(x);
    return i + 1;
}

// Uvarint decodes a uint64 from buf and returns that value and the
// number of bytes read (> 0). If an error occurred, the value is 0
// and the number of bytes n is <= 0 meaning:
//
//	n == 0: buf too small
//	n  < 0: value larger than 64 bits (overflow)
//	        and -n is the number of bytes read
R<uint64, int> Uvarint(slice<> buf) {
    uint64 x = 0;
    uint s = 0;
    // for i, b := range buf {
    for (int i = 0; i < len(buf); i++) {
        auto b = buf[i];
        if (i == MaxVarintLen64) {
            // Catch byte reads past MaxVarintLen64.
            // See issue https://golang.org/issues/41185
            return {0, -(i + 1)};  // overflow
        }
        if (b < 0x80) {
            if (i == MaxVarintLen64 - 1 && b > 1) {
                return {0, -(i + 1)};  // overflow
            }
            return {x | (uint64(b) << s), i + 1};
        }
        x |= uint64(b & 0x7f) << s;
        s += 7;
    }
    return {0, 0};
}

// AppendVarint appends the varint-encoded form of x,
// as generated by PutVarint, to buf and returns the extended buffer.
slice<> AppendVarint(slice<> buf, int64 x) {
    uint64 ux = uint64(x) << 1;
    if (x < 0) {
        ux = ~ux;
    }
    return AppendUvarint(buf, ux);
}

// PutVarint encodes an int64 into buf and returns the number of bytes written.
// If the buffer is too small, PutVarint will panic.
int PutVarint(slice<> buf, int64 x) {
    uint64 ux = uint64(x) << 1;
    if (x < 0) {
        ux = ~ux;
    }
    return PutUvarint(buf, ux);
}

// Varint decodes an int64 from buf and returns that value and the
// number of bytes read (> 0). If an error occurred, the value is 0
// and the number of bytes n is <= 0 with the following meaning:
//
//	n == 0: buf too small
//	n  < 0: value larger than 64 bits (overflow)
//	        and -n is the number of bytes read
R<int64, int> Varint(slice<> buf) {
    AUTO_R(ux, n, Uvarint(buf));  // ok to continue in presence of error
    int64 x = int64(ux >> 1);
    if ((ux & 1) != 0) {
        x = ~x;
    }
    return {x, n};
}

static error overflow = errors::New("binary: varint overflows a 64-bit integer");

// ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.
R<uint64, error> ReadUvarint(io::ByteReader r) {
    uint64 x = 0;
    uint s = 0;
    for (int i = 0; i < MaxVarintLen64; i++) {
        AUTO_R(b, err, r->ReadByte());
        if (err != nil) {
            return {x, err};
        }
        if (b < 0x80) {
            if (i == MaxVarintLen64 - 1 && b > 1) {
                return {x, overflow};
            }
            return {x | uint64(b) << s, nil};
        }
        x |= uint64(b & 0x7f) << s;
        s += 7;
    }
    return {x, overflow};
}

// ReadVarint reads an encoded signed integer from r and returns it as an int64.
R<int64, error> ReadVarint(io::ByteReader r) {
    AUTO_R(ux, err, ReadUvarint(r));  // ok to continue in presence of error
    int64 x = int64(ux >> 1);
    if ((ux & 1) != 0) {
        x = ~x;
    }
    return {x, err};
}

}  // namespace binary
}  // namespace gx
